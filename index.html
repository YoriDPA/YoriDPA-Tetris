<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jogo Tetris Minimalista</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e; /* Fundo escuro */
            color: #e0e0e0;
            font-family: 'Press Start 2P', cursive;
            touch-action: none; /* Impede o navegador de usar gestos de toque padrão */
        }
        #game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative; /* Necessário para elementos posicionados absolutamente */
        }
        canvas#tetris-canvas {
            background-color: #0f0f1a;
            border: 4px solid #4a4e69;
            border-radius: 8px;
            box-sizing: border-box; /* Garante que a borda não aumente o tamanho total */
        }
        #modal-overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75);
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }
        #modal-content {
            background: #1a1a2e; padding: 30px; border-radius: 10px;
            border: 3px solid #fca311; text-align: center; max-width: 90%;
        }
        #modal-content h1 { font-size: 2rem; margin-bottom: 1rem; }
        #modal-content p { font-size: 1rem; margin-bottom: 1.5rem; }
        #modal-content button {
            background-color: #fca311; color: #1a1a2e; padding: 10px 20px;
            border: none; border-radius: 5px; font-family: 'Press Start 2P', cursive;
            font-size: 1rem; cursor: pointer; transition: background-color 0.2s;
        }
        #modal-content button:hover { background-color: #ffc300; }

        /* Estilo para o popup de pontuação */
        #score-popup {
            position: absolute;
            top: 30px;
            background-color: rgba(252, 163, 17, 0.85);
            color: #1a1a2e;
            padding: 10px 25px;
            border-radius: 20px;
            font-size: 1.2rem;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #score-popup.show {
            opacity: 1;
        }
        
        /* Estilo para a assinatura do desenvolvedor */
        #dev-signature {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: white;
            opacity: 0.4;
            pointer-events: none;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        <canvas id="tetris-canvas"></canvas>
        <div id="score-popup">
            <span id="score">0</span>
        </div>
        <!-- Assinatura do Desenvolvedor -->
        <div id="dev-signature">Dev. YoriDPA</div>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <h1 id="modal-title">TETRIS</h1>
            <p id="modal-text">Controles: Setas (PC) ou Toque/Arraste (Celular).</p>
            <button id="start-button">Iniciar Jogo</button>
            <!-- Assinatura na tela inicial -->
            <p style="font-size: 0.8rem; margin-top: 25px; opacity: 0.7;">Dev. YoriDPA</p>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('tetris-canvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');

    const modalOverlay = document.getElementById('modal-overlay');
    const modalTitle = document.getElementById('modal-title');
    const modalText = document.getElementById('modal-text');
    const startButton = document.getElementById('start-button');
    
    const scorePopup = document.getElementById('score-popup');
    const scoreEl = document.getElementById('score');

    const COLS = 10;
    const ROWS = 20;
    let blockSize;
    let board = [];

    const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877F5'];
    const SHAPES = [
        [], // Vazio
        [[1, 1, 1, 1]], // I
        [[2, 2], [2, 2]], // O
        [[0, 3, 0], [3, 3, 3]], // T
        [[4, 4, 0], [0, 4, 4]], // S
        [[0, 5, 5], [5, 5, 0]], // Z
        [[6, 0, 0], [6, 6, 6]], // L
        [[0, 0, 7], [7, 7, 7]]  // J
    ];

    let player;
    let nextPiece;
    let score;
    let lines;
    let level;
    let dropCounter;
    let dropInterval;
    let lastTime;
    let isGameOver = true;
    let animationFrameId;
    let scoreTimeout;

    function createBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function createPiece(type) {
        const matrix = SHAPES[type];
        return {
            x: 0,
            y: 0,
            matrix: matrix,
            type: type
        };
    }

    function resetPlayer() {
        if (!nextPiece) {
            player = createPiece(Math.floor(Math.random() * 7) + 1);
            nextPiece = createPiece(Math.floor(Math.random() * 7) + 1);
        } else {
            player = nextPiece;
            nextPiece = createPiece(Math.floor(Math.random() * 7) + 1);
        }
        
        player.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
        player.y = 0;
        
        if (checkCollision(board, player)) {
            gameOver();
        }
    }

    function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMatrix(board, { x: 0, y: 0 });
        if(player) {
            drawMatrix(player.matrix, { x: player.x, y: player.y });
        }
    }
    
    function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    ctx.fillStyle = COLORS[value];
                    ctx.fillRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                    ctx.strokeStyle = '#0f0f1a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                }
            });
        });
    }

    function merge(board, player) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + player.y][x + player.x] = value;
                }
            });
        });
    }

    function checkCollision(board, player) {
        if (!player) return false;
        for (let y = 0; y < player.matrix.length; y++) {
            for (let x = 0; x < player.matrix[y].length; x++) {
                if (player.matrix[y][x] !== 0 &&
                   (board[y + player.y] && board[y + player.y][x + player.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function rotate(matrix) {
        const newMatrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        return newMatrix.map(row => row.reverse());
    }

    function playerRotate() {
        if (!player) return;
        const pos = player.x;
        let offset = 1;
        player.matrix = rotate(player.matrix);

        while (checkCollision(board, player)) {
            player.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > player.matrix[0].length) {
                player.matrix = rotate(rotate(rotate(player.matrix)));
                player.x = pos;
                return;
            }
        }
    }

    function playerMove(dir) {
        if (!player) return;
        player.x += dir;
        if (checkCollision(board, player)) {
            player.x -= dir;
        }
    }

    function playerDrop() {
        if (!player) return;
        player.y++;
        if (checkCollision(board, player)) {
            player.y--;
            merge(board, player);
            sweepLines();
            resetPlayer();
        }
        dropCounter = 0;
    }
    
    function playerHardDrop() {
        if (!player) return;
        while (!checkCollision(board, player)) {
            player.y++;
        }
        player.y--;
        merge(board, player);
        sweepLines();
        resetPlayer();
        dropCounter = 0;
    }

    function sweepLines() {
        let clearedLines = 0;
        outer: for (let y = board.length - 1; y > 0; --y) {
            for (let x = 0; x < board[y].length; ++x) {
                if (board[y][x] === 0) {
                    continue outer;
                }
            }
            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            ++y;
            clearedLines++;
        }
        
        if (clearedLines > 0) {
            lines += clearedLines;
            const points = [0, 100, 300, 500, 800][clearedLines] * level;
            score += points;

            scoreEl.textContent = score;
            scorePopup.classList.add('show');
            
            if (scoreTimeout) clearTimeout(scoreTimeout);
            scoreTimeout = setTimeout(() => {
                scorePopup.classList.remove('show');
            }, 1500);

            if (Math.floor(lines / 10) + 1 > level) {
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(150, 1000 - (level * 50));
            }
        }
    }

    function update(time = 0) {
        if (isGameOver) return;

        if (!lastTime) lastTime = time;
        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            playerDrop();
        }
        draw();
        animationFrameId = requestAnimationFrame(update);
    }
    
    function handleResize() {
        const containerWidth = gameContainer.clientWidth;
        const containerHeight = gameContainer.clientHeight;

        const blockSizeW = containerWidth / COLS;
        const blockSizeH = containerHeight / ROWS;
        
        blockSize = Math.floor(Math.min(blockSizeW, blockSizeH));

        canvas.width = COLS * blockSize;
        canvas.height = ROWS * blockSize;
        
        if (!isGameOver) {
            draw();
        }
    }
    
    function startGame() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        isGameOver = false;
        board = createBoard();
        score = 0;
        lines = 0;
        level = 1;
        dropInterval = 1000;
        dropCounter = 0;
        lastTime = 0;
        player = null;
        nextPiece = null;
        
        scorePopup.classList.remove('show');
        if (scoreTimeout) clearTimeout(scoreTimeout);
        
        handleResize();
        resetPlayer();
        
        modalOverlay.style.display = 'none';
        
        update();
    }

    function gameOver() {
        isGameOver = true;
        cancelAnimationFrame(animationFrameId);
        modalTitle.innerText = "FIM DE JOGO";
        modalText.innerText = `Sua pontuação final: ${score}`;
        startButton.innerText = "Jogar Novamente";
        modalOverlay.style.display = 'flex';
    }

    document.addEventListener('keydown', event => {
        if (isGameOver) return;
        if (event.key === 'ArrowLeft') playerMove(-1);
        else if (event.key === 'ArrowRight') playerMove(1);
        else if (event.key === 'ArrowDown') playerDrop();
        else if (event.key === 'ArrowUp') playerRotate();
        else if (event.code === 'Space') playerHardDrop();
    });
    
    let touchStartX = 0;
    let touchStartY = 0;
    let isDragging = false;

    document.addEventListener('touchstart', e => {
        if (isGameOver) return;
        e.preventDefault();
        isDragging = false;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, { passive: false });

    document.addEventListener('touchmove', e => {
        if (isGameOver) return;
        e.preventDefault(); 
        
        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const dx = touchCurrentX - touchStartX;
        const dy = touchCurrentY - touchStartY;

        if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
            isDragging = true;
        }

        if (Math.abs(dx) > blockSize) {
            playerMove(dx > 0 ? 1 : -1);
            touchStartX = touchCurrentX;
            touchStartY = touchCurrentY;
        }
    }, { passive: false });
    
    document.addEventListener('touchend', e => {
        if (isGameOver) return;

        if (!isDragging) {
            playerRotate();
            return;
        }

        const touchEndY = e.changedTouches[0].clientY;
        const dy = touchEndY - touchStartY;
        const dx = e.changedTouches[0].clientX - touchStartX;

        if (dy > Math.abs(dx) && dy > 50) {
            playerHardDrop();
        }
    });

    window.addEventListener('resize', handleResize);
    startButton.addEventListener('click', startGame);
    handleResize();

    </script>
</body>
</html>
