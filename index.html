<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jogo Tetris Competitivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Biblioteca de Ã¡udio Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #1a1a2e; color: #e0e0e0;
            font-family: 'Orbitron', sans-serif; touch-action: none;
        }
        #game-container {
            display: flex; justify-content: center; align-items: center;
            width: 100%; height: 100%; position: relative;
        }
        canvas#tetris-canvas {
            background-color: #0f0f1a; border: 4px solid #4a4e69;
            border-radius: 8px; box-sizing: border-box;
        }
        .overlay {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75);
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: #1a1a2e; padding: 30px; border-radius: 10px;
            border: 3px solid #fca311; text-align: center; max-width: 90%;
            width: 400px;
        }
        .modal-content h1 { font-size: 2rem; margin-bottom: 1rem; }
        .modal-content p { font-size: 1rem; margin-bottom: 1.5rem; }
        .modal-content button {
            background-color: #fca311; color: #1a1a2e; padding: 10px 20px;
            border: none; border-radius: 5px; font-family: 'Orbitron', sans-serif;
            font-weight: 700; font-size: 1rem; cursor: pointer;
            transition: background-color 0.2s; margin: 5px;
        }
        .modal-content button:hover { background-color: #ffc300; }
        .modal-content button:disabled { background-color: #555; cursor: not-allowed; }
        #score-popup {
            position: absolute; top: 30px; background-color: rgba(252, 163, 17, 0.85);
            color: #1a1a2e; padding: 10px 25px; border-radius: 20px;
            font-size: 1.2rem; font-weight: 700; z-index: 10;
            pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        #score-popup.show { opacity: 1; }
        #dev-signature {
            position: absolute; bottom: 10px; right: 15px;
            font-size: 0.8rem; color: white; opacity: 0.4; pointer-events: none;
        }
        #high-scores-container {
            margin-top: 20px; max-height: 200px; overflow-y: auto;
            background-color: rgba(0,0,0,0.3); border-radius: 5px; padding: 10px;
        }
        #high-scores-list {
            list-style: none; padding: 0; margin: 0; text-align: left;
        }
        #high-scores-list li {
            padding: 5px 10px; border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        #high-scores-list li:last-child { border-bottom: none; }
        #high-scores-list li .rank {
            display: inline-block; width: 30px; font-weight: bold; color: #fca311;
        }
        #high-scores-list li .name { font-weight: bold; }
        #high-scores-list li .score { float: right; }
        #player-name-input {
            background-color: #0f0f1a; border: 2px solid #4a4e69; color: white;
            padding: 8px; border-radius: 5px; text-align: center;
            font-family: 'Orbitron', sans-serif; margin-bottom: 10px;
        }
        #mute-button {
            position: absolute; top: 20px; left: 20px;
            width: 50px; height: 50px; background-color: rgba(252, 163, 17, 0.8);
            border-radius: 50%; border: 2px solid #1a1a2e; color: #1a1a2e;
            font-size: 1.5rem; font-weight: bold; display: flex;
            justify-content: center; align-items: center; cursor: pointer; z-index: 50;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="game-container">
        <canvas id="tetris-canvas"></canvas>
        <div id="score-popup"><span id="score">0</span></div>
        <div id="dev-signature">Dev. YoriDPA</div>
        <div id="mute-button">ðŸ”Š</div>
    </div>

    <div id="modal-overlay" class="overlay">
        <div class="modal-content">
            <h1 id="modal-title">TETRIS</h1>
            <p id="modal-text">Controles: Setas (PC) ou Toque/Arraste (Celular).</p>
            <div id="game-over-content" class="hidden">
                <input type="text" id="player-name-input" placeholder="Digite seu nome" maxlength="10">
                <button id="save-score-button">Salvar Recorde</button>
            </div>
            <div>
                <button id="start-button">Iniciar Jogo</button>
                <button id="scores-button">Recordes</button>
            </div>
            <div id="high-scores-container" class="hidden">
                <ul id="high-scores-list"></ul>
            </div>
            <p style="font-size: 0.8rem; margin-top: 25px; opacity: 0.7;">Dev. YoriDPA</p>
        </div>
    </div>

    <script type="module">
        // ImportaÃ§Ãµes do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, getDoc, setDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Adia a execuÃ§Ã£o de todo o cÃ³digo do jogo atÃ© que a pÃ¡gina esteja totalmente carregada
        window.addEventListener('load', () => {
            // --- VariÃ¡veis Globais e ConfiguraÃ§Ã£o ---
            const canvas = document.getElementById('tetris-canvas');
            const ctx = canvas.getContext('2d');
            const gameContainer = document.getElementById('game-container');
            const modalOverlay = document.getElementById('modal-overlay');
            const modalTitle = document.getElementById('modal-title');
            const modalText = document.getElementById('modal-text');
            const startButton = document.getElementById('start-button');
            const scoresButton = document.getElementById('scores-button');
            const highScoresContainer = document.getElementById('high-scores-container');
            const highScoresList = document.getElementById('high-scores-list');
            const scorePopup = document.getElementById('score-popup');
            const scoreEl = document.getElementById('score');
            const gameOverContent = document.getElementById('game-over-content');
            const playerNameInput = document.getElementById('player-name-input');
            const saveScoreButton = document.getElementById('save-score-button');
            const muteButton = document.getElementById('mute-button');

            const COLS = 10;
            const ROWS = 20;
            let blockSize;
            let board = [];

            const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877F5'];
            const SHAPES = [
                [], [[1, 1, 1, 1]], [[2, 2], [2, 2]], [[0, 3, 0], [3, 3, 3]],
                [[4, 4, 0], [0, 4, 4]], [[0, 5, 5], [5, 5, 0]], [[6, 0, 0], [6, 6, 6]],
                [[0, 0, 7], [7, 7, 7]]
            ];

            let player, nextPiece, score, lines, level, dropCounter, dropInterval, lastTime;
            let isGameOver = true;
            let animationFrameId, scoreTimeout;

            // --- ConfiguraÃ§Ã£o de Ãudio com Tone.js ---
            let audioInitialized = false;
            let musicSynth, scoreSynth, musicLoop;

            // --- ConfiguraÃ§Ã£o do Firebase ---
            let db, auth;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tetris-app';
            
            async function initFirebase() {
                try {
                    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Erro ao inicializar o Firebase:", error);
                }
            }

            // --- FunÃ§Ãµes do Jogo ---
            function createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
            function createPiece(type) { return { x: 0, y: 0, matrix: SHAPES[type], type: type }; }
            function resetPlayer() {
                if (!nextPiece) {
                    player = createPiece(Math.floor(Math.random() * 7) + 1);
                    nextPiece = createPiece(Math.floor(Math.random() * 7) + 1);
                } else {
                    player = nextPiece;
                    nextPiece = createPiece(Math.floor(Math.random() * 7) + 1);
                }
                player.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
                player.y = 0;
                if (checkCollision(board, player)) gameOver();
            }
            function draw() {
                if (!ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMatrix(board, { x: 0, y: 0 });
                if(player) drawMatrix(player.matrix, { x: player.x, y: player.y });
            }
            function drawMatrix(matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            ctx.fillStyle = COLORS[value];
                            ctx.fillRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                            ctx.strokeStyle = '#0f0f1a';
                            ctx.lineWidth = 2;
                            ctx.strokeRect((offset.x + x) * blockSize, (offset.y + y) * blockSize, blockSize, blockSize);
                        }
                    });
                });
            }
            function merge(board, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) board[y + player.y][x + player.x] = value;
                    });
                });
            }
            function checkCollision(board, player) {
                if (!player) return false;
                for (let y = 0; y < player.matrix.length; y++) {
                    for (let x = 0; x < player.matrix[y].length; x++) {
                        if (player.matrix[y][x] !== 0 && (board[y + player.y] && board[y + player.y][x + player.x]) !== 0) return true;
                    }
                }
                return false;
            }
            function rotate(matrix) {
                const newMatrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
                return newMatrix.map(row => row.reverse());
            }
            function playerRotate() {
                if (!player) return;
                const pos = player.x;
                let offset = 1;
                player.matrix = rotate(player.matrix);
                while (checkCollision(board, player)) {
                    player.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > player.matrix[0].length) {
                        player.matrix = rotate(rotate(rotate(player.matrix)));
                        player.x = pos;
                        return;
                    }
                }
            }
            function playerMove(dir) {
                if (!player) return;
                player.x += dir;
                if (checkCollision(board, player)) player.x -= dir;
            }
            function playerDrop() {
                if (!player) return;
                player.y++;
                if (checkCollision(board, player)) {
                    player.y--;
                    merge(board, player);
                    sweepLines();
                    resetPlayer();
                }
                dropCounter = 0;
            }
            function playerHardDrop() {
                if (!player) return;
                while (!checkCollision(board, player)) player.y++;
                player.y--;
                merge(board, player);
                sweepLines();
                resetPlayer();
                dropCounter = 0;
            }
            function sweepLines() {
                let clearedLines = 0;
                outer: for (let y = board.length - 1; y > 0; --y) {
                    for (let x = 0; x < board[y].length; ++x) {
                        if (board[y][x] === 0) continue outer;
                    }
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    y++;
                    clearedLines++;
                }
                if (clearedLines > 0) {
                    if(scoreSynth) scoreSynth.triggerAttackRelease("C5", "8n");
                    lines += clearedLines;
                    score += [0, 100, 300, 500, 800][clearedLines] * level;
                    scoreEl.textContent = score;
                    scorePopup.classList.add('show');
                    if (scoreTimeout) clearTimeout(scoreTimeout);
                    scoreTimeout = setTimeout(() => scorePopup.classList.remove('show'), 1500);
                    if (Math.floor(lines / 10) + 1 > level) {
                        level = Math.floor(lines / 10) + 1;
                        dropInterval = Math.max(150, 1000 - (level * 50));
                    }
                }
            }
            function update(time = 0) {
                if (isGameOver) return;
                if (!lastTime) lastTime = time;
                const deltaTime = time - lastTime;
                lastTime = time;
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) playerDrop();
                draw();
                animationFrameId = requestAnimationFrame(update);
            }
            function handleResize() {
                const containerWidth = gameContainer.clientWidth;
                const containerHeight = gameContainer.clientHeight;
                const blockSizeW = containerWidth / COLS;
                const blockSizeH = containerHeight / ROWS;
                blockSize = Math.floor(Math.min(blockSizeW, blockSizeH));
                canvas.width = COLS * blockSize;
                canvas.height = ROWS * blockSize;
                if (!isGameOver) draw();
            }
            
            function initAudio() {
                if (audioInitialized || typeof window.Tone === 'undefined') return;
                musicSynth = new window.Tone.Synth({
                    oscillator: { type: 'fmsquare' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.1 }
                }).toDestination();
                
                scoreSynth = new window.Tone.Synth({
                    oscillator: { type: 'triangle8' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
                }).toDestination();

                musicLoop = new window.Tone.Sequence((time, note) => {
                    if (musicSynth) musicSynth.triggerAttackRelease(note, '8n', time);
                }, ['C2', ['E2', 'G2'], 'A2', 'G2'], '4n');
                
                window.Tone.Transport.bpm.value = 120;
                audioInitialized = true;
            }

            async function startGame() {
                try {
                    if (typeof window.Tone !== 'undefined' && !audioInitialized) {
                        await window.Tone.start();
                        initAudio();
                    }
                    if (window.Tone && window.Tone.Transport.state !== 'started') {
                        window.Tone.Transport.start();
                    }
                    if (musicLoop) musicLoop.start(0);
                } catch (e) {
                    console.error("Falha ao iniciar o Ã¡udio:", e);
                }

                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                isGameOver = false;
                board = createBoard();
                score = 0; lines = 0; level = 1;
                dropInterval = 1000; dropCounter = 0; lastTime = 0;
                player = null; nextPiece = null;
                scorePopup.classList.remove('show');
                if (scoreTimeout) clearTimeout(scoreTimeout);
                handleResize();
                resetPlayer();
                modalOverlay.style.display = 'none';
                update();
            }

            async function gameOver() {
                isGameOver = true;
                if (window.Tone && window.Tone.Transport.state === 'started') {
                    window.Tone.Transport.stop();
                }
                if (musicLoop) musicLoop.stop();
                cancelAnimationFrame(animationFrameId);
                
                modalTitle.innerText = "FIM DE JOGO";
                modalText.innerText = `Sua pontuaÃ§Ã£o final: ${score}`;
                startButton.innerText = "Jogar Novamente";
                highScoresContainer.classList.add('hidden');
                
                try {
                    if (score > 0) {
                        await handlePlayerRecord();
                    } else {
                        gameOverContent.classList.add('hidden');
                    }
                } catch (error) {
                    console.error("Erro ao processar recorde:", error);
                    gameOverContent.classList.add('hidden');
                    modalText.innerText += "\n(NÃ£o foi possÃ­vel salvar o recorde)";
                } finally {
                    modalOverlay.style.display = 'flex';
                }
            }

            // --- LÃ“GICA DE RECORDES COM FIREBASE ---
            async function handlePlayerRecord() {
                if (!auth.currentUser) return;
                const userId = auth.currentUser.uid;
                const userDocRef = doc(db, `/artifacts/${appId}/users/${userId}`);
                const userDocSnap = await getDoc(userDocRef);

                if (userDocSnap.exists() && userDocSnap.data().name) {
                    const playerName = userDocSnap.data().name;
                    modalText.innerText += `\nRecorde salvo para ${playerName}.`;
                    gameOverContent.classList.add('hidden');
                    await updatePlayerBestScore(userId, playerName, score);
                } else {
                    gameOverContent.classList.remove('hidden');
                    playerNameInput.value = '';
                    saveScoreButton.disabled = false;
                    saveScoreButton.innerText = "Salvar Recorde";
                }
            }
            
            async function updatePlayerBestScore(userId, name, newScore) {
                if (!db) return;
                const scoreDocRef = doc(db, `/artifacts/${appId}/public/data/tetris_highscores/${userId}`);
                const scoreDocSnap = await getDoc(scoreDocRef);

                if (scoreDocSnap.exists()) {
                    const oldScore = scoreDocSnap.data().score;
                    if (newScore > oldScore) {
                        await setDoc(scoreDocRef, { name, score: newScore, createdAt: new Date() });
                    }
                } else {
                    await setDoc(scoreDocRef, { name, score: newScore, createdAt: new Date() });
                }
            }

            async function displayHighScores() {
                if (!db) return;
                highScoresList.innerHTML = '<li>Carregando...</li>';
                
                try {
                    const scoresCollection = collection(db, `/artifacts/${appId}/public/data/tetris_highscores`);
                    const q = query(scoresCollection, orderBy("score", "desc"), limit(10));
                    const querySnapshot = await getDocs(q);
                    
                    let scores = [];
                    querySnapshot.forEach((doc) => {
                        scores.push(doc.data());
                    });
                    
                    highScoresList.innerHTML = '';

                    if (scores.length === 0) {
                        highScoresList.innerHTML = '<li>Nenhum recorde ainda.</li>';
                    } else {
                        scores.forEach((scoreData, index) => {
                            const li = document.createElement('li');
                            li.innerHTML = `<span class="rank">#${index + 1}</span> <span class="name">${scoreData.name}</span> <span class="score">${scoreData.score}</span>`;
                            highScoresList.appendChild(li);
                        });
                    }
                } catch (e) {
                    console.error("Erro ao buscar recordes: ", e);
                    highScoresList.innerHTML = '<li>Erro ao carregar recordes.</li>';
                }
            }

            // --- Controles e Event Listeners ---
            document.addEventListener('keydown', event => {
                if (isGameOver) return;
                if (event.key === 'ArrowLeft') playerMove(-1);
                else if (event.key === 'ArrowRight') playerMove(1);
                else if (event.key === 'ArrowDown') playerDrop();
                else if (event.key === 'ArrowUp') playerRotate();
                else if (event.code === 'Space') playerHardDrop();
            });
            
            let touchStartX, touchStartY, isDragging;
            document.addEventListener('touchstart', e => {
                if (isGameOver) return;
                e.preventDefault();
                isDragging = false;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, { passive: false });

            document.addEventListener('touchmove', e => {
                if (isGameOver) return;
                e.preventDefault(); 
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                if (Math.abs(dx) > 20 || Math.abs(dy) > 20) isDragging = true;
                if (Math.abs(dx) > blockSize) {
                    playerMove(dx > 0 ? 1 : -1);
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            }, { passive: false });
            
            document.addEventListener('touchend', e => {
                if (isGameOver) return;
                if (!isDragging) {
                    playerRotate();
                    return;
                }
                const dy = e.changedTouches[0].clientY - touchStartY;
                const dx = e.changedTouches[0].clientX - touchStartX;
                if (dy > Math.abs(dx) && dy > 50) playerHardDrop();
            });

            window.addEventListener('resize', handleResize);
            startButton.addEventListener('click', startGame);
            scoresButton.addEventListener('click', () => {
                displayHighScores();
                highScoresContainer.classList.toggle('hidden');
            });
            saveScoreButton.addEventListener('click', async () => {
                const name = playerNameInput.value.trim();
                if (name && auth.currentUser) {
                    saveScoreButton.disabled = true;
                    saveScoreButton.innerText = "Salvando...";
                    const userId = auth.currentUser.uid;
                    await setDoc(doc(db, `/artifacts/${appId}/users/${userId}`), { name: name });
                    await updatePlayerBestScore(userId, name, score);
                    saveScoreButton.innerText = "Salvo!";
                } else {
                    alert("Por favor, digite seu nome.");
                }
            });
            muteButton.addEventListener('click', () => {
                if (!audioInitialized) return;
                window.Tone.Destination.mute = !window.Tone.Destination.mute;
                muteButton.textContent = window.Tone.Destination.mute ? 'ðŸ”‡' : 'ðŸ”Š';
            });

            // --- InicializaÃ§Ã£o do App ---
            async function main() {
                await initFirebase();
                handleResize();
            }
            
            main();
        });
    </script>
</body>
</html>
