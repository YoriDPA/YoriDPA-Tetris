<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake.io 2D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 3px solid #34495e;
            background-color: #1a1a1a;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            max-width: 95vw;
            max-height: 80vh;
            width: auto;
            height: auto;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #34495e;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        .score-display {
            font-size: 1.5rem;
            margin-top: 15px;
            color: #ecf0f1;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #ecf0f1;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2rem;
            text-align: center;
            display: none;
            z-index: 100;
        }
        .game-message button {
            background-color: #2ecc71;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2rem;
            margin-top: 20px;
            transition: background-color 0.3s ease;
        }
        .game-message button:hover {
            background-color: #27ae60;
        }
        #chartCanvas {
            margin-top: 20px;
            background-color: #1a1a2e;
            border-radius: 10px;
            max-width: 90%;
            transform: scale(0);
            transition: transform 0.5s ease;
        }
        #chartCanvas.show {
            transform: scale(1);
        }
        .growth-message {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            color: #2ecc71;
            font-size: 1.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            opacity: 0;
            transition: opacity 1s ease;
        }
        .boost-meter {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
        }
        .boost-fill {
            height: 100%;
            background-color: #2ecc71;
            border-radius: 5px;
            transition: width 0.2s ease;
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div class="game-container rounded-lg shadow-xl p-6 bg-gray-700">
        <h1 class="text-3xl font-bold mb-4 text-green-400">Snake.io 2D</h1>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="boost-meter">
            <div id="boostFill" class="boost-fill" style="width: 100%;"></div>
        </div>
        <p class="score-display">PontuaÃ§Ã£o: <span id="score">0</span> | Tamanho: <span id="length">1</span></p>
        <canvas id="chartCanvas" width="400" height="200" style="display: none;"></canvas>
        <div id="growthMessage" class="growth-message"></div>
    </div>

    <div id="gameEndMessage" class="game-message">
        <p id="gameEndText"></p>
        <button id="restartButton">Reiniciar Jogo</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const lengthDisplay = document.getElementById('length');
        const gameEndMessage = document.getElementById('gameEndMessage');
        const gameEndText = document.getElementById('gameEndText');
        const restartButton = document.getElementById('restartButton');
        const chartCanvas = document.getElementById('chartCanvas');
        const chartCtx = chartCanvas.getContext('2d');
        const growthMessage = document.getElementById('growthMessage');
        const boostFill = document.getElementById('boostFill');

        // Game settings
        const mapWidth = 3000;
        const mapHeight = 3000;
        const segmentSize = 15;
        let snake = [{ x: mapWidth / 2, y: mapHeight / 2 }];
        let food = {};
        let powerUps = [];
        let score = 0;
        let baseSpeed = 5;
        let speed = baseSpeed;
        let targetAngle = 0;
        let currentAngle = 0;
        let mousePos = { x: mapWidth / 2 + 50, y: mapHeight / 2 };
        const camera = { x: 0, y: 0 };
        let particles = [];
        let gameRunning = true;
        let scoreHistory = [{ time: 0, score: 0, length: 1 }];
        let gameTime = 0;
        let lastScoreUpdate = 0;

        // Boost
        let isBoosting = false;
        const boostCostPerFrame = 0.2;
        const boostSpeedMultiplier = 2;
        let boostCooldown = 0;

        // AI snakes
        let aiSnakes = [];
        const maxAiSnakes = 5;
        const aiInitialLength = 5;

        // Stars
        const numStars = 200;
        let stars = [];

        // Initialize game
        window.onload = function() {
            resizeCanvas();
            resetGame();
            gameLoop();
        };

        // Resize canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.min(800, container.clientWidth * 0.95);
            canvas.height = Math.min(600, container.clientHeight * 0.8);
            if (snake.length > 0) {
                camera.x = snake[0].x - canvas.width / 2;
                camera.y = snake[0].y - canvas.height / 2;
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // Mouse movement
        canvas.addEventListener('mousemove', (e) => {
            if (!gameRunning) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mousePos.x = camera.x + (e.clientX - rect.left) * scaleX;
            mousePos.y = camera.y + (e.clientY - rect.top) * scaleY;
            console.log(`Mouse: (${mousePos.x}, ${mousePos.y}), Food: (${food.x}, ${food.y})`);
        });

        // Boost
        canvas.addEventListener('mousedown', () => {
            if (gameRunning && boostCooldown === 0) isBoosting = true;
        });

        canvas.addEventListener('mouseup', () => {
            isBoosting = false;
        });

        // Restart
        restartButton.addEventListener('click', () => {
            gameEndMessage.style.display = 'none';
            chartCanvas.style.display = 'none';
            growthMessage.style.opacity = '0';
            resetGame();
            gameRunning = true;
            gameLoop();
        });

        // Generate food
        function generateFood() {
            food = {
                x: Math.random() * mapWidth,
                y: Math.random() * mapHeight
            };
            console.log(`New food at: (${food.x}, ${food.y})`);
        }

        // Generate power-up
        function generatePowerUp() {
            if (Math.random() < 0.005) {
                powerUps.push({
                    x: Math.random() * mapWidth,
                    y: Math.random() * mapHeight,
                    type: Math.random() < 0.5 ? 'speed' : 'shrink'
                });
            }
        }

        // Generate particles
        function generateParticles(x, y, color = 'rgba(255, 255, 255, 0.7)', count = 10, size = 3, spread = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * spread,
                    vy: (Math.random() - 0.5) * spread,
                    life: 30,
                    color: color,
                    size: size
                });
            }
        }

        // Show growth message
        function showGrowthMessage(length) {
            if (length % 10 === 0) {
                growthMessage.textContent = `Crescimento CÃ³smico! Tamanho: ${length}`;
                growthMessage.style.opacity = '1';
                setTimeout(() => { growthMessage.style.opacity = '0'; }, 2000);
            }
        }

        // AI snakes
        function createAiSnake() {
            const startX = Math.random() * mapWidth;
            const startY = Math.random() * mapHeight;
            const newAiSnake = {
                segments: [{ x: startX, y: startY }],
                direction: Math.random() * Math.PI * 2,
                speed: baseSpeed * 0.8,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                turnCooldown: 0
            };
            for (let i = 0; i < aiInitialLength - 1; i++) {
                newAiSnake.segments.push({ x: startX - (i + 1) * segmentSize, y: startY });
            }
            aiSnakes.push(newAiSnake);
        }

        function updateAiSnakes() {
            if (aiSnakes.length < maxAiSnakes && Math.random() < 0.001) {
                createAiSnake();
            }

            aiSnakes = aiSnakes.filter(aiSnake => {
                if (aiSnake.segments.length === 0) return false;

                const head = { ...aiSnake.segments[0] };
                aiSnake.turnCooldown--;
                if (aiSnake.turnCooldown <= 0) {
                    if (Math.random() < 0.5) {
                        const angleToFood = Math.atan2(food.y - head.y, food.x - head.x);
                        aiSnake.direction = angleToFood + (Math.random() - 0.5) * Math.PI / 4;
                    } else {
                        aiSnake.direction += (Math.random() - 0.5) * Math.PI / 2;
                    }
                    aiSnake.turnCooldown = Math.floor(Math.random() * 60) + 30;
                }

                head.x += Math.cos(aiSnake.direction) * aiSnake.speed;
                head.y += Math.sin(aiSnake.direction) * aiSnake.speed;

                if (head.x < 0) head.x += mapWidth;
                if (head.x > mapWidth) head.x -= mapWidth;
                if (head.y < 0) head.y += mapHeight;
                if (head.y > mapHeight) head.y -= mapHeight;

                aiSnake.segments.unshift(head);

                if (Math.hypot(head.x - food.x, head.y - food.y) < segmentSize) {
                    generateFood();
                    // AI cresce ao comer comida
                } else {
                    aiSnake.segments.pop();
                }

                for (let i = 2; i < aiSnake.segments.length; i++) {
                    if (Math.hypot(head.x - aiSnake.segments[i].x, head.y - aiSnake.segments[i].y) < segmentSize * 0.8) {
                        generateParticles(head.x, head.y, aiSnake.color, 20, 5, 10);
                        return false;
                    }
                }

                return true;
            });
        }

        // Stars
        function initStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * mapWidth,
                    y: Math.random() * mapHeight,
                    size: Math.random() * 2 + 1,
                    alpha: Math.random(),
                    speed: Math.random() * 0.1 + 0.05,
                    direction: Math.random() * Math.PI * 2,
                    life: Math.random() * 100 + 50
                });
            }
        }

        function updateStars() {
            for (let star of stars) {
                star.alpha = Math.abs(Math.sin(star.life / 50));
                star.life = (star.life + star.speed) % 200;
                star.x += Math.cos(star.direction) * 0.1;
                star.y += Math.sin(star.direction) * 0.1;
                if (star.x < 0) star.x = mapWidth;
                if (star.x > mapWidth) star.x = 0;
                if (star.y < 0) star.y = mapHeight;
                if (star.y > mapHeight) star.y = 0;
            }
        }

        // Update game state
        function update() {
            if (!gameRunning) return;

            gameTime += 1 / 60;
            if (gameTime - lastScoreUpdate >= 1) {
                scoreHistory.push({ time: Math.floor(gameTime), score: Math.floor(score), length: snake.length });
                lastScoreUpdate = gameTime;
            }

            const head = { ...snake[0] };
            targetAngle = Math.atan2(mousePos.y - head.y, mousePos.x - head.x);
            currentAngle += (targetAngle - currentAngle) * 0.2; // Increased smoothing

            let currentSpeed = baseSpeed + Math.min(snake.length * 0.05, 10);
            if (isBoosting && score > boostCostPerFrame && boostCooldown === 0) {
                currentSpeed *= boostSpeedMultiplier;
                score = Math.max(0, score - boostCostPerFrame);
                scoreDisplay.textContent = Math.floor(score);
                boostFill.style.width = `${(score / 100) * 100}%`; // Update boost meter
            } else {
                isBoosting = false;
                boostFill.style.width = `${(score / 100) * 100}%`;
            }

            if (boostCooldown > 0) boostCooldown--;

            head.x += Math.cos(currentAngle) * currentSpeed;
            head.y += Math.sin(currentAngle) * currentSpeed;

            if (head.x < 0 || head.x > mapWidth || head.y < 0 || head.y > mapHeight) {
                gameOver("VocÃª atingiu a borda do mapa!");
                generateParticles(head.x, head.y, 'rgba(255, 0, 0, 0.8)', 50, 8, 15);
                return;
            }

            for (let i = 2; i < snake.length; i++) {
                if (Math.hypot(head.x - snake[i].x, head.y - snake[i].y) < segmentSize * 0.8) {
                    gameOver("VocÃª colidiu com vocÃª mesmo!");
                    generateParticles(head.x, head.y, 'rgba(255, 0, 0, 0.8)', 50, 8, 15);
                    return;
                }
            }

            snake.unshift(head);

            if (Math.hypot(head.x - food.x, head.y - food.y) < segmentSize) {
                score += 10;
                scoreDisplay.textContent = Math.floor(score);
                generateFood();
                generateParticles(food.x, food.y, '#9b59b6', 20, 5, 8); // More particles for growth
                showGrowthMessage(snake.length + 1);
            } else {
                snake.pop();
            }

            lengthDisplay.textContent = snake.length;

            powerUps = powerUps.filter(p => {
                if (Math.hypot(head.x - p.x, head.y - p.y) < segmentSize) {
                    if (p.type === 'speed') {
                        boostCooldown = 0;
                        generateParticles(p.x, p.y, '#f1c40f', 15, 4, 7);
                    } else if (p.type === 'shrink') {
                        snake.length = Math.max(1, snake.length - 5);
                        generateParticles(p.x, p.y, '#3498db', 15, 4, 7);
                        lengthDisplay.textContent = snake.length;
                    }
                    return false;
                }
                return true;
            });

            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                return p.life > 0;
            });

            generatePowerUp();
            updateAiSnakes();

            aiSnakes = aiSnakes.filter(aiSnake => {
                const aiHead = aiSnake.segments[0];
                for (let i = 0; i < aiSnake.segments.length; i++) {
                    if (Math.hypot(head.x - aiSnake.segments[i].x, head.y - aiSnake.segments[i].y) < segmentSize * 0.9) {
                        if (snake.length > aiSnake.segments.length * 1.5) {
                            score += aiSnake.segments.length * 5;
                            scoreDisplay.textContent = Math.floor(score);
                            generateParticles(aiHead.x, aiHead.y, aiSnake.color, 30, 6, 12);
                            return false;
                        } else {
                            gameOver("VocÃª colidiu com uma entidade inimiga!");
                            generateParticles(head.x, head.y, 'rgba(255, 0, 0, 0.8)', 50, 8, 15);
                            return true;
                        }
                    }
                }
                return true;
            });

            for (let i = 0; i < aiSnakes.length; i++) {
                const aiSnake = aiSnakes[i];
                const aiHead = aiSnake.segments[0];
                for (let j = 0; j < snake.length; j++) {
                    if (Math.hypot(aiHead.x - snake[j].x, aiHead.y - snake[j].y) < segmentSize * 0.9) {
                        if (aiSnake.segments.length > snake.length * 1.5) {
                            gameOver("Uma entidade inimiga maior te devorou!");
                            generateParticles(head.x, head.y, 'rgba(255, 0, 0, 0.8)', 50, 8, 15);
                            aiSnakes.splice(i, 1);
                            return;
                        } else {
                            generateParticles(aiHead.x, aiHead.y, aiSnake.color, 30, 6, 12);
                            aiSnakes.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }
            }

            updateStars();

            camera.x = head.x - canvas.width / 2;
            camera.y = head.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(camera.x, mapWidth - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, mapHeight - canvas.height));
        }

        // Draw
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const bgGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            bgGradient.addColorStop(0, '#1a1a2e');
            bgGradient.addColorStop(1, '#0f0f2b');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let star of stars) {
                const starX = star.x - camera.x;
                const starY = star.y - camera.y;
                if (starX > -star.size && starX < canvas.width + star.size &&
                    starY > -star.size && starY < canvas.height + star.size) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                    ctx.beginPath();
                    ctx.arc(starX, starY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            const gridSize = 50;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            for (let x = -camera.x % gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = -camera.y % gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(mousePos.x - camera.x, mousePos.y - camera.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = `rgba(46, 204, 113, ${isBoosting ? 0.5 : 0.3})`;
            ctx.lineWidth = segmentSize;
            ctx.beginPath();
            for (let i = 1; i < snake.length; i++) {
                ctx.moveTo(snake[i-1].x - camera.x, snake[i-1].y - camera.y);
                ctx.lineTo(snake[i].x - camera.x, snake[i].y - camera.y);
            }
            ctx.stroke();

            for (let p of particles) {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let aiSnake of aiSnakes) {
                for (let i = 0; i < aiSnake.segments.length; i++) {
                    const alpha = 1 - (i / aiSnake.segments.length) * 0.5;
                    ctx.fillStyle = `hsla(${aiSnake.color.substring(4, aiSnake.color.indexOf(','))}, 70%, 50%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(aiSnake.segments[i].x - camera.x, aiSnake.segments[i].y - camera.y, segmentSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `hsla(${aiSnake.color.substring(4, aiSnake.color.indexOf(','))}, 70%, 40%, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            for (let i = 0; i < snake.length; i++) {
                const alpha = 1 - (i / snake.length) * 0.5;
                ctx.fillStyle = `rgba(46, 204, 113, ${alpha})`;
                ctx.beginPath();
                ctx.arc(snake[i].x - camera.x, snake[i].y - camera.y, segmentSize / 2, 0, Math.PI * 2);
                ctx.fill();
                if (isBoosting) {
                    ctx.save();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `rgba(0, 255, 0, ${alpha})`;
                    ctx.fill();
                    ctx.restore();
                }
                ctx.strokeStyle = `rgba(39, 174, 96, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.fillStyle = '#9b59b6';
            ctx.beginPath();
            ctx.arc(food.x - camera.x, food.y - camera.y, segmentSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8e44ad';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.font = `${segmentSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('ðŸ’Ž', food.x - camera.x, food.y - camera.y);

            for (let p of powerUps) {
                let color, borderColor, icon;
                if (p.type === 'speed') {
                    color = '#f1c40f';
                    borderColor = '#f39c12';
                    icon = 'âš¡';
                } else {
                    color = '#3498db';
                    borderColor = '#2980b9';
                    icon = 'â¬‡ï¸';
                }
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, segmentSize / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.font = `${segmentSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(icon, p.x - camera.x, p.y - camera.y);
            }
        }

        // Game over
        function gameOver(message) {
            gameRunning = false;
            gameEndText.textContent = `Fim de Jogo! ${message} Sua pontuaÃ§Ã£o final foi: ${Math.floor(score)}\n${getScoreMessage(score)}`;
            gameEndMessage.style.display = 'block';
            chartCanvas.style.display = 'block';
            chartCanvas.classList.add('show');
            drawChart();
        }

        // Score message
        function getScoreMessage(score) {
            if (score >= 200) return "VocÃª Ã© um Devorador Estelar Ã‰pico!";
            if (score >= 100) return "Ã“timo trabalho, Viajante CÃ³smico!";
            if (score >= 50) return "Bom progresso, Explorador!";
            return "Continue tentando, Novato Estelar!";
        }

        // Chart
        let chart = null;
        function drawChart() {
            if (chart) chart.destroy();
            chart = new Chart(chartCtx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'PontuaÃ§Ã£o ao Longo do Tempo',
                        data: scoreHistory.map(entry => ({ x: entry.time, y: entry.score })),
                        borderColor: '#2ecc71',
                        backgroundColor: 'rgba(46, 204, 113, 0.2)',
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'Tamanho da Cobra',
                        data: scoreHistory.map(entry => ({ x: entry.time, y: entry.length || 1 })),
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.2)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Tempo (segundos)', color: '#fff' },
                            grid: { color: 'rgba(255, 255, 255, 0.2)' },
                            ticks: { color: '#fff' }
                        },
                        y: {
                            title: { display: true, text: 'PontuaÃ§Ã£o/Tamanho', color: '#fff' },
                            grid: { color: 'rgba(255, 255, 255, 0.2)' },
                            ticks: { color: '#fff' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#fff' } }
                    }
                }
            });
        }

        // Reset game
        function resetGame() {
            snake = [{ x: mapWidth / 2, y: mapHeight / 2 }];
            generateFood();
            powerUps = [];
            score = 0;
            speed = baseSpeed;
            scoreHistory = [{ time: 0, score: 0, length: 1 }];
            gameTime = 0;
            lastScoreUpdate = 0;
            scoreDisplay.textContent = score;
            lengthDisplay.textContent = snake.length;
            mousePos = { x: mapWidth / 2 + 50, y: mapHeight / 2 };
            isBoosting = false;
            boostCooldown = 0;
            particles = [];
            aiSnakes = [];
            initStars();
            camera.x = snake[0].x - canvas.width / 2;
            camera.y = snake[0].y - canvas.height / 2;
        }

        // Main game loop
        function gameLoop() {
            if (gameRunning) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // Start game
        gameLoop();
    </script>
</body>
</html>
